import sqlite3
import psycopg2
import os
from dotenv import load_dotenv
import sys

# Carregar variáveis de ambiente
load_dotenv()

# Configuração do banco de dados PostgreSQL
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://postgres:admin@localhost/investment_tracker")

# Extrair informações de conexão do DATABASE_URL
db_parts = DATABASE_URL.replace('postgresql://', '').split('/')
db_name = db_parts[1]
db_conn_parts = db_parts[0].split('@')
db_user_pass = db_conn_parts[0].split(':')
db_host_port = db_conn_parts[1].split(':')

db_user = db_user_pass[0]
db_pass = db_user_pass[1] if len(db_user_pass) > 1 else ''
db_host = db_host_port[0]
db_port = db_host_port[1] if len(db_host_port) > 1 else '5432'

# Caminho para o banco de dados SQLite
sqlite_db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'investment_tracker.db')

def check_sqlite_db():
    """Verifica se o banco SQLite existe e tem dados"""
    if not os.path.exists(sqlite_db_path):
        print(f"Erro: Banco de dados SQLite não encontrado em {sqlite_db_path}")
        return False
    
    try:
        conn = sqlite3.connect(sqlite_db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        conn.close()
        
        if not tables:
            print("Aviso: Banco de dados SQLite não contém tabelas.")
            return False
        
        print(f"Banco SQLite encontrado com {len(tables)} tabelas.")
        return True
    except Exception as e:
        print(f"Erro ao verificar banco SQLite: {e}")
        return False

def check_postgres_connection():
    """Verifica se é possível conectar ao PostgreSQL"""
    try:
        conn = psycopg2.connect(
            dbname=db_name,
            user=db_user,
            password=db_pass,
            host=db_host,
            port=db_port
        )
        conn.close()
        print("Conexão com PostgreSQL estabelecida com sucesso.")
        return True
    except Exception as e:
        print(f"Erro ao conectar ao PostgreSQL: {e}")
        return False

def get_sqlite_tables():
    """Obtém lista de tabelas do SQLite"""
    conn = sqlite3.connect(sqlite_db_path)
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    tables = [table[0] for table in cursor.fetchall() if table[0] != 'sqlite_sequence']
    conn.close()
    return tables

def get_table_schema(table_name):
    """Obtém esquema de uma tabela SQLite"""
    conn = sqlite3.connect(sqlite_db_path)
    cursor = conn.cursor()
    cursor.execute(f"PRAGMA table_info({table_name});")
    columns = cursor.fetchall()
    conn.close()
    return columns

def sqlite_to_postgres_type(sqlite_type):
    """Converte tipo de dados SQLite para PostgreSQL"""
    sqlite_type = sqlite_type.upper()
    if 'INT' in sqlite_type:
        return 'INTEGER'
    elif 'CHAR' in sqlite_type or 'TEXT' in sqlite_type or 'CLOB' in sqlite_type:
        return 'TEXT'
    elif 'REAL' in sqlite_type or 'FLOA' in sqlite_type or 'DOUB' in sqlite_type:
        return 'FLOAT'
    elif 'BOOL' in sqlite_type:
        return 'BOOLEAN'
    elif 'DATE' in sqlite_type or 'TIME' in sqlite_type:
        return 'TIMESTAMP'
    else:
        return 'TEXT'  # Tipo padrão

def create_postgres_tables(tables):
    """Cria tabelas no PostgreSQL baseado no esquema SQLite"""
    conn = psycopg2.connect(
        dbname=db_name,
        user=db_user,
        password=db_pass,
        host=db_host,
        port=db_port
    )
    cursor = conn.cursor()
    
    for table in tables:
        columns = get_table_schema(table)
        
        # Criar definição de colunas
        column_defs = []
        primary_key = None
        
        for col in columns:
            col_id, col_name, col_type, not_null, default_val, is_pk = col
            pg_type = sqlite_to_postgres_type(col_type)
            
            col_def = f'"{col_name}" {pg_type}'
            
            if is_pk:
                primary_key = col_name
                if 'INT' in col_type.upper():
                    col_def += " GENERATED BY DEFAULT AS IDENTITY"
            
            if not_null:
                col_def += " NOT NULL"
                
            column_defs.append(col_def)
        
        # Adicionar PRIMARY KEY se existir
        if primary_key:
            column_defs.append(f'PRIMARY KEY ("{primary_key}")')
        
        # Criar tabela
        create_table_sql = f"CREATE TABLE IF NOT EXISTS {table} (\n  {',\n  '.join(column_defs)}\n);"
        print(f"\nCriando tabela {table}...")
        print(create_table_sql)
        
        try:
            cursor.execute(create_table_sql)
            print(f"Tabela {table} criada com sucesso.")
        except Exception as e:
            print(f"Erro ao criar tabela {table}: {e}")
    
    conn.commit()
    conn.close()

def migrate_data(tables):
    """Migra dados do SQLite para o PostgreSQL"""
    sqlite_conn = sqlite3.connect(sqlite_db_path)
    sqlite_cursor = sqlite_conn.cursor()
    
    pg_conn = psycopg2.connect(
        dbname=db_name,
        user=db_user,
        password=db_pass,
        host=db_host,
        port=db_port
    )
    pg_cursor = pg_conn.cursor()
    
    for table in tables:
        print(f"\nMigrando dados da tabela {table}...")
        
        # Obter colunas
        sqlite_cursor.execute(f"PRAGMA table_info({table});")
        columns = [col[1] for col in sqlite_cursor.fetchall()]
        columns_str = '", "'.join(columns)
        
        # Obter dados
        sqlite_cursor.execute(f"SELECT * FROM {table};")
        rows = sqlite_cursor.fetchall()
        
        if not rows:
            print(f"Tabela {table} está vazia. Pulando...")
            continue
        
        print(f"Encontradas {len(rows)} linhas para migrar.")
        
        # Limpar tabela PostgreSQL antes de inserir
        try:
            pg_cursor.execute(f'TRUNCATE TABLE {table} RESTART IDENTITY CASCADE;')
        except Exception as e:
            print(f"Aviso ao limpar tabela {table}: {e}")
        
        # Preparar SQL para inserção
        placeholders = ', '.join(['%s'] * len(columns))
        insert_sql = f'INSERT INTO {table} ("{columns_str}") VALUES ({placeholders});'
        
        # Inserir dados em lotes
        batch_size = 100
        for i in range(0, len(rows), batch_size):
            batch = rows[i:i+batch_size]
            try:
                pg_cursor.executemany(insert_sql, batch)
                pg_conn.commit()
                print(f"Inseridas {len(batch)} linhas na tabela {table}.")
            except Exception as e:
                pg_conn.rollback()
                print(f"Erro ao inserir dados na tabela {table}: {e}")
    
    sqlite_conn.close()
    pg_conn.close()

def main():
    print("=== Migração de SQLite para PostgreSQL ===")
    print(f"Banco SQLite: {sqlite_db_path}")
    print(f"PostgreSQL: {db_host}:{db_port}/{db_name}")
    
    # Verificar banco SQLite
    if not check_sqlite_db():
        print("Migração abortada: Problemas com o banco SQLite.")
        return
    
    # Verificar conexão PostgreSQL
    if not check_postgres_connection():
        print("Migração abortada: Não foi possível conectar ao PostgreSQL.")
        return
    
    # Perguntar ao usuário se deseja continuar
    response = input("\nDeseja continuar com a migração? (s/n): ")
    if response.lower() != 's':
        print("Migração cancelada pelo usuário.")
        return
    
    # Obter tabelas do SQLite
    tables = get_sqlite_tables()
    print(f"\nTabelas encontradas: {', '.join(tables)}")
    
    # Criar tabelas no PostgreSQL
    create_postgres_tables(tables)
    
    # Migrar dados
    migrate_data(tables)
    
    print("\n=== Migração concluída! ===")

if __name__ == "__main__":
    main()